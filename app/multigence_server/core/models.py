import uuid

from django.conf import settings
from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager
from django.contrib.auth.models import PermissionsMixin
# from django.contrib.postgres.fields import JSONField
from django.db import models
from django.utils import timezone

class LowerCaseEmailField(models.EmailField):
    def get_prep_value(self, value):
        value = super(LowerCaseEmailField, self).get_prep_value(value)
        if value is not None:
            value = value.lower()
        return value

class Company(models.Model):
    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=128, unique=True)
    trial = models.BooleanField(default=False)
    invitations = models.IntegerField(null=False, blank=False, default=0)
    invitations_sent = models.IntegerField(null=False, blank=False, default=0)

    def __str__(self):
        return self.name


class Position(models.Model):
    class Meta:
        unique_together = ('name', 'company')

    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=128)
    company = models.ForeignKey(Company, on_delete=models.CASCADE)

    def __str__(self):
        return self.company.name + " - " + self.name


class Department(models.Model):
    class Meta:
        unique_together = ('name', 'company')

    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=128)
    company = models.ForeignKey(Company, on_delete=models.CASCADE)

    def __str__(self):
        return self.company.name + " - " + self.name


class Question(models.Model):
    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    text = models.JSONField(blank=False, null=False)

    def __str__(self):
        return str(self.text)


class Questionary(models.Model):
    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    id = models.CharField(max_length=64, null=False, blank=False)
    name = models.CharField(max_length=128)
    max_points = models.IntegerField(null=False, blank=False, default=22)
    questions = models.ManyToManyField(Question, through='QuestionaryQuestion')
    company = models.OneToOneField(Company, on_delete=models.CASCADE)

    def get_questions(self):
        return self.questions.order_by('question_to_questionary')

    def __str__(self):
        return self.name + " (" + self.company.name + ")"


# TODO-HIGH this index is actually not used, instead questions are order by ID! Add to admin area? Or remove (but then ID is autogenerated, that might become a problem)
class QuestionaryQuestion(models.Model):
    questionary = models.ForeignKey(Questionary, on_delete=models.CASCADE)
    question = models.ForeignKey(Question, related_name='question_to_questionary', on_delete=models.CASCADE)
    index = models.IntegerField(default=0)

    class Meta:
        ordering = ['index']


class Sphere(models.Model):
    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=128, unique=True)
    COLLECTIVE = 'COLLECTIVE'
    INDIVIDUAL = 'INDIVIDUAL'
    NONE = 'NONE'
    TYPE_CHOICES = (
        (COLLECTIVE, 'Collective'),
        (INDIVIDUAL, 'Individual'),
        (NONE, 'None'),
    )
    type = models.CharField(max_length=20, choices=TYPE_CHOICES, default=NONE, null=False, blank=False)
    index = models.IntegerField(default=0)

    def __str__(self):
        return self.name + " (" + self.type + ")"


class QuestionOption(models.Model):
    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    question = models.ForeignKey(Question, related_name='options', on_delete=models.CASCADE)
    text = models.JSONField(blank=False, null=False)
    sphere = models.ForeignKey(Sphere, on_delete=models.CASCADE)

    def __str__(self):
        return "Question (" + str(self.question)[:20] + ") " + str(self.text)[:20] + " (" + self.sphere.name + ")"


class QuestionaryResult(models.Model):
    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    questionary = models.ForeignKey(Questionary, on_delete=models.CASCADE)

    CREATED = 'CREATED'
    IN_PROGRESS = 'IN_PROGRESS'
    DONE = 'DONE'
    STATUS_CHOICES = (
        (CREATED, 'Created'),
        (IN_PROGRESS, 'In progress'),
        (DONE, 'Done'),
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default=CREATED)

    def __str__(self):
        return self.user.email + " (" + self.questionary.name + ")"


class Answer(models.Model):
    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    created = models.DateTimeField(auto_now_add=True)
    questionary_result = models.OneToOneField(QuestionaryResult, on_delete=models.CASCADE)

    def __str__(self):
        return "Answer (" + self.questionary_result.questionary.name + ")"


class AnswerQuestionOptionPoints(models.Model):
    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    answer = models.ForeignKey(Answer, on_delete=models.CASCADE)
    question_option = models.ForeignKey(QuestionOption, on_delete=models.CASCADE)
    points = models.IntegerField(blank=False, null=False)

    def __str__(self):
        return str(self.question_option.text) + ": " + str(self.points)


class CustomUserManager(BaseUserManager):
    def _create_user(self, email, password, **extra_fields):
        if not email:
            raise ValueError('Users must have an email address')
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_user(self, email, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', False)
        extra_fields.setdefault('is_superuser', False)
        return self._create_user(email, password, **extra_fields)

    def create_superuser(self, email, password, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)

        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')

        return self._create_user(email, password, **extra_fields)


class User(AbstractBaseUser, PermissionsMixin):
    first_name = models.CharField(max_length=30, blank=True)
    first_name_alias = models.CharField(max_length=30, blank=True)
    last_name = models.CharField(max_length=30, blank=True)
    last_name_alias = models.CharField(max_length=30, blank=True)
    email = LowerCaseEmailField(max_length=255, unique=True)
    is_staff = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    date_joined = models.DateTimeField(default=timezone.now)

    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    department = models.ForeignKey(Department, null=False, blank=False, on_delete=models.CASCADE)
    title = models.CharField(max_length=512, blank=True, null=True)
    position = models.ForeignKey(Position, blank=True, null=True, on_delete=models.CASCADE)

    EMPLOYEE = 'EMPLOYEE'
    APPLICANT = 'APPLICANT'
    MANAGER = 'MANAGER'
    ADMIN = 'ADMIN'
    ROLE_CHOICES = ((EMPLOYEE, 'Employee'), (APPLICANT, 'Applicant'), (MANAGER, 'Company manager'), (ADMIN, 'Admin'))
    role = models.CharField(max_length=20, choices=ROLE_CHOICES, default=EMPLOYEE)

    # profile
    MALE = "MALE"
    FEMALE = "FEMALE"
    UNSPECIFIED = "UNSPECIFIED"
    GENDER_CHOICES = ((MALE, 'Male'), (FEMALE, 'Female'), (UNSPECIFIED, 'Unspecified'))
    gender = models.CharField(max_length=32, choices=GENDER_CHOICES, blank=True, null=True)

    address = models.CharField(max_length=512, null=True, blank=True)
    zipcode = models.CharField(max_length=10, null=True, blank=True)
    state = models.CharField(max_length=128, null=True, blank=True)
    country = models.CharField(max_length=128, null=True, blank=True)
    telephone = models.CharField(max_length=32, null=True, blank=True)
    website = models.URLField(null=True, blank=True)
    profile_picture = models.URLField(null=True, blank=True)

    description = models.TextField(null=True, blank=True)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []

    objects = CustomUserManager()

    def __str__(self):
        if self.first_name and self.last_name:
            return self.first_name + " " + self.last_name
        else:
            return self.email

    def get_short_name(self):
        if self.first_name:
            return self.first_name
        else:
            return self.email

    def get_full_name(self):
        if self.first_name and self.last_name:
            return self.first_name + " " + self.last_name
        else:
            return self.email


